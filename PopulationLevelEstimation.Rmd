# 集団レベルの推定 {#PopulationLevelEstimation}

*著者: Martijn Schuemie, David Madigan, Marc Suchard & Patrick Ryan*

\index{population-level estimation}

保険請求データや電子健康記録などの観察的な医療データは、治療の効果に関する現実世界のエビデンスを生成する機会を提供し、患者の生活を有意に改善することができます。本章では、特定の健康アウトカムに対する曝露（例えば、薬剤曝露やプロシージャー（処置）などの医療介入）の平均的な因果効果の推定を指す集団レベルの効果推定に焦点を当てます。以下では、2つの異なる推定タスクを検討します：

-   **直接効果推定**: アウトカムのリスクに対する曝露の効果を、曝露なしと比較して推定する。 \index{direct effect estimation}
-   **比較効果推定**: アウトカムのリスクに対する曝露（ターゲット曝露）の効果を、別の曝露（比較曝露）と比較して推定する。 \index{comparative effect estimation}

いずれの場合でも、患者レベルの因果効果は事実のアウトカム、すなわち曝露を受けた患者に何が起こったかと、反事実のアウトカム、すなわち曝露がなかった場合（直接）や異なる曝露があった場合（比較）に何が起こったかを対比させます。各患者は事実のアウトカムのみを明らかにするため（因果推論の基本問題）、さまざまな効果推定デザインは異なるデバイスを使用して反事実のアウトカムを明らかにします。 \index{counterfactual}

集団レベルの効果推定のユースケースには、治療選択、安全性監視、および比較効果が含まれます。方法論は、特定の仮説を一度に1つずつテストすること（例：「シグナル評価」）や、複数の仮説を一度に探索すること（例：「シグナル検出」）ができます。いずれの場合も、目的は同じです：因果効果の高品質な推定を生成することです。 \index{safety surveillance} \index{comparative effectiveness|see {comparative effect estimation}}

本章ではまず、[OHDSI Methods Library](https://ohdsi.github.io/MethodsLibrary/)としてRパッケージで実装されているさまざまな集団レベルの推定研究デザインについて説明します。次に、具体的な推定研究の設計を詳細に説明し、ATLASおよびRを使用して設計を実装する手順ガイドを提供します。最後に、研究から生成されるさまざまな出力、包括的な研究診断および効果サイズの推定についてレビューします。

## コホートメソッド設計 {#CohortMethod}

\index{cohort method}

```{r cohortMethod, fig.cap='新規ユーザーコホートデザイン。ターゲット治療を開始した対象は比較対照治療を開始した対象と比較されます。2つの治療グループ間の違いを調整するために、傾向スコアによる層化、マッチング、または重み付け、あるいはベースライン特性をアウトカムモデルに追加するなど、いくつかの調整戦略が使用されます。傾向スコアモデルまたはアウトカムモデルに含まれる特性は治療開始前に取得されます。',echo=FALSE, out.width='90%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/cohortMethod.png")
```

コホートメソッドはランダム化臨床試験を模倣することを試みます [@hernan_2016]。 ある治療（ターゲット）を開始した対象は別の治療（比較対照）を開始した対象と比較され、治療開始後の特定の期間、例えば治療を継続する期間にわたって追跡されます。コホート研究において私たちが答えたい質問は、表 \@ref(tab:cmChoices) にハイライトされた5つの選択を行うことで具体化されます。 \index{target cohort!cohort method} \index{comparator cohort} \index{outcome cohort!cohort method}

| 選択 | 説明 |
|:---|:---|
| ターゲットコホート | ターゲット治療を代表するコホート |
| 比較対照コホート | 比較対照治療を代表するコホート |
| アウトカムコホート | 関心のあるアウトカムを代表するコホート |
| リスク期間 | どの時点で（通常はターゲットおよび比較対照コホートの開始および終了日）アウトカムのリスクを考慮するか |
| モデル | ターゲットと比較対照の間の違いを調整しながら効果を推定するために使用されるモデル |

: (#tab:cmChoices) 比較コホートデザインの主要な設計選択

モデルの選択には、他の要素の中でも、アウトカムモデルの種類が含まれます。例えば、ロジスティック回帰を使用することができ、これはアウトカムが発生したかどうかを評価し、オッズ比を生成します。ロジスティック回帰はリスク期間がターゲットと比較対照で同じ長さであるか、または関係がないと仮定します。代替的に、定常発生率を仮定するポアソン回帰を選ぶこともできます。よく使用されるのは、リスク比を推定するための初回アウトカムまでの時間を考慮するコックス回帰であり、ターゲットと比較対照間で比例ハザードを仮定します。 \index{logistic regression} \index{Poisson regression} \index{Cox regression} \index{Cox proportional hazards model|see {Cox regression}}

```{block2, type='rmdimportant'}
新規ユーザーコホートメソッドは本質的に比較効果推定の方法であり、治療を比較対照と比較します。この方法を使用して治療対未治療を比較するのは難しいです。なぜなら、未曝露群と曝露群が比較可能な群を定義するのが難しいからです。この設計を直接的な効果推定に使用したい場合は、関心のある曝露に対する比較対照として、同じ適応症に対する治療を選択するのが望ましいです。ただし、必ずしもそのような比較対照が利用可能であるとは限りません。

```

重要な懸念は、ターゲット治療を受ける患者が比較対照治療を受ける患者と系統的に異なる可能性があることです。例えば、ターゲットコホートが平均60歳であり、比較対照コホートが平均40歳であるとします。年齢に関連する健康アウトカム（例：脳卒中）に関してターゲットと比較対照を比較する場合、コホート間で顕著な違いが見られるかもしれません。無知な研究者は、ターゲット治療と比較対照に比べて脳卒中の間に因果関係があると結論づけるかもしれません。もっと平凡な、あるいはありふれた結論として、ターゲット患者が脳卒中を経験したことが、比較対照を受けていたらそうならなかったであろうと結論づけるかもしれません。この結論は完全に間違っている可能性があります！おそらくこれらのターゲット患者は、ただ年を取っているだけで脳卒中が発生したかもしれません。治療を受けていたとしても同様であった可能性があります。この文脈では、年齢は「交絡因子」です。観察研究で交絡因子に対処する一つのメカニズムは傾向スコアを介することです。 \index{confounder}

### 傾向スコア

\index{propensity score}

ランダム化試験では、（仮想的な）コイントスが患者を各グループに割り当てます。したがって、設計によって、患者がターゲット治療を受ける確率は患者の特性（例：年齢）とは無関係です。コインは患者を知りませんし、何よりも、ターゲット曝露を受ける患者の確率を正確にはっきりと知っています。そのアウトカム、試験の患者数が増えるにつれて、両方のグループの患者はどのような患者特性においても体系的に異なることは基本的にできません。このバランスの保証は、試験が測定した特性（例：年齢）および試験が測定しなかった特性（例：患者の遺伝的要因）にも適用されます。 \index{randomized trial}

ある患者に対する*傾向スコア（PS）*は、その患者がターゲット治療を受ける確率です [@rosenbaum_1983]。 バランスの取れた二群ランダム化試験では、傾向スコアはすべての患者に対して0.5です。傾向スコアで補正された観察研究では、治療開始時およびその前のデータに基づいて患者がターゲット治療を受ける確率を推定します（実際に受けた治療に関係なく）。これは単純な予測モデリングの応用です。ロジスティック回帰などのモデルを適合させ、患者がターゲット治療を受けるかどうかを予測し、各被験者の予測確率（PS）を生成するためにこのモデルを使用します。標準的なランダム化試験とは異なり、異なる患者は異なるターゲット治療を受ける確率を持ちます。PSは、PSが似たターゲット被験者と比較対照被験者をマッチングする、PSに基づいて研究集団を層化する、PSから導き出された治療重み付けの逆確率（IPTW）を使うなど、いくつかの方法で使用できます。マッチングの場合、各ターゲット対象被験者に対して一人の比較対照対象だけを選択することも、一人以上の比較対照対象被験者を許容することもできます。これを可変比マッチングと言います [@rassen_2012]。 \index{propensity model} \index{propensity score!matching} \index{propensity score!stratification} \index{propensity score!weighting} \index{inverse probability of treatment weighting (IPTW)|see {propensity score!weighting}} \index{variable ratio matching}

例えば、一対一のPSマッチングを用いるとします。Janのターゲット治療を受ける事前確率が0.4であり、実際にターゲット治療を受けたとします。もし、事前確率0.4でターゲット治療を受けるはずだったが実際には比較対照を受けた患者（Junという名前）が見つかれば、JanとJunのアウトカムを比較することは、測定された交絡因子に関しては、小規模なランダム化試験のようなものです。この比較は、ランダム化によって生成されるJan-Jun因果コントラストの推定をもたらします。次に、推定のための手順は次のようになります：ターゲット治療を受けた各患者に対して、事前確率が同じで比較対照治療を受けた一人以上の患者を見つけ、これらのマッチング群内でターゲット患者のアウトカムを比較対照患者のアウトカムと比較します。

傾向スコアは測定された交絡因子を制御します。実際、測定された特性がない場合、採用された推定方法に基づいて誤差のない因果効果の推定値が得られます。測定された特性は「強い無視可能性」を仮定します。 “強い無視可能性”は実際にはテストできない前提です。この問題についての詳細は第 \@ref(MethodValidity) 章で説明します。 \index{strongly ignorable}

### 変数選択 {#VariableSelection}

以前は、PSは手動で選択された特性に基づいて計算されていましたが、OHDSIツールはそのような実践をサポートする一方で、特定の曝露およびアウトカムに基づいて選択されていない、より多くの汎用特性を使用することを好みます [@tian_2018] 。これらの特性には、人口統計情報、治療開始前および当日に観察されたコンディション、薬剤曝露、メジャーメント（測定）、および医療プロシージャーが含まれます。通常、モデルには10,000から100,000の特有の特性が含まれ、これらを大規模な正則化回帰 [@suchard_2013] を使用して適合させ、[Cyclops](https://ohdsi.github.io/Cyclops/)パッケージで実装します。本質的には、どの特性が治療割り当ての予測に関連するかをデータに決定させ、モデルに含めます。

```{block2, type='rmdimportant'}
典型的には、治療開始日の特性は治療の原因となる診断などの多くの関連データがその日に記録されているため、共変量収集ウィンドウに含まれるべきです。この日には、ターゲットおよび比較対照の治療自体も記録されているが、これらは傾向スコアモデルに含まれるべきではありません。なぜなら、私たちはまさにこれらを予測しようとしているからです。したがって、ターゲットおよび比較対照治療は共変量セットから明示的に除外する必要があります。

```

一部の人々は、因果構造を特定するために臨床専門知識に依存しない共変量選択のデータ駆動型アプローチは、誤っていわゆる道具変数や交絡因子を含め、分散を増加させ、潜在的にバイアスを導入するリスクがあると主張します [@hernan_2002]。しかし、これらの懸念は現実的なシナリオでは大きな影響を与える可能性は低いです [@schneeweiss_2018]。さらに、医学においては真の因果構造が判明することはほとんどなく、異なる研究者が特定の研究問題に対して「正しい」共変量を特定するように求められると、それぞれの研究者は必ず異なるリストを作成し、そのプロセスを再現不能にします。最も重要なのは、傾向スコアモデルの確認、すべての共変量のバランス評価、および否定的対照の含有などの診断によって、交絡因子や道具変数に関連するほとんどの問題を特定できることです。 \index{instrumental variables} \index{colliders}

### カリパー

\index{caliper}

傾向スコアは0から1の連続体上にあるため、厳密なマッチングはほとんど不可能です。代わりに、マッチングプロセスはターゲット患者の傾向スコアと一致する患者を「カリパー」として知られる許容範囲内で見つけます。 @austin_2011 に従い、ロジットスケールで標準偏差の0.2を使用します。

### オーバーラップ：選好スコア

\index{preference score}

傾向スコア方法は一致する患者が存在することを必要とします。このため、主要な診断は二つのグループの傾向スコアの分布を示します。解釈を容易にするために、OHDSIツールは「選好スコア」と呼ばれる傾向スコアの変換をプロットします。選好スコアは二つの治療の「市場占有率」を調整します。例えば、10%の患者がターゲット治療を受ける場合（比較対照治療を受ける患者が90%の場合）、選好スコアが0.5の患者はターゲット治療を受ける確率が10%です。数学的に、選好スコアは

$$\ln\left(\frac{F}{1-F}\right)=\ln\left(\frac{S}{1-S}\right)-\ln\left(\frac{P}{1-P}\right)$$

ここで $F$ は選好スコア、$S$ は傾向スコア、$P$ はターゲット治療を受ける患者の割合です。

@walker_2013 は「経験的均衡」のコンセプトを述べています。彼らは、少なくとも半数の曝露が選好スコアの0.3から0.7の間にある場合、これらの曝露ペアを経験的均衡にあると見なします。 \index{clinical equipoise}

### バランス

\index{covariate balance} \index{balance|see {covariate balance}}

良い実践は常にPS調整がバランスの取れた患者群を生成するかどうかをチェックします。図 \@ref(fig:balance)はバランスをチェックするための標準的なOHDSI出力を示しています。各患者特性について、露出グループ間の平均の標準化差をPS調整前後でプロットします。いくつかのガイドラインは、PS調整後の標準化差の上限を0.1とすることを推奨しています [@rubin_2001]。

## 自己対照コホートデザイン

\index{self-controlled cohort design}

```{r scc, fig.cap='自己対照コホートデザイン。ターゲットへの曝露中のアウトカムの発生率を曝露前の時間中の発生率と比較します。',echo=FALSE, out.width='90%', fig.align='center', fig.pos='h'}
knitr::include_graphics("images/PopulationLevelEstimation/selfControlledCohort.png")
```

自己対照コホート（SCC）デザイン [@ryan_2013] は曝露中のアウトカムの発生率を、曝露直前の時間におけるアウトカムの発生率と比較します。表 \@ref(tab:sccChoices) に示す4つの選択肢が、自己対照コホートの質問を定義します。 \index{target cohort!self-controlled cohort design} \index{outcome cohort!self-controlled cohort design}

```{r sccChoices, echo=FALSE}
table <- read.table(header = TRUE, sep = "|", stringsAsFactors = FALSE, strip.white = TRUE, text = "
| 選択              | 説明                                             |
|:----------------- |:-------------------------------------------------------- |
| ターゲットコホート| 治療を表すコホート                                       |
| アウトカムコホート| 関心のあるアウトカムを表すコホート                             |
| リスク時間        | アウトカムのリスクをどのタイミング（通常ターゲットコホートの開始および終了日が基準）で考慮するか？     |
| 対照時間          | 対照時間として使用される期間                   |
")
table <- table[-1, 2:(ncol(table) - 1), -1]
table <- knitr::kable(table, caption = "自己対照コホートデザインの主要な設計選択肢。", booktabs = TRUE, row.names = FALSE)
if ( knitr:::is_latex_output()) {
  table <- kableExtra::kable_styling(table, full_width = FALSE)
  table <- kableExtra::column_spec(table, 2, width = "9cm")
}
table
```

曝露群を構成する同じ被験者が対照群としても使用されるため、被験者間の差異について調整する必要はありません。ただし、この方法は、異なる期間間のアウトカムの基礎リスクの差異など、他の違いには脆弱です。

## 症例対照デザイン

\index{case-control design}

```{r caseControl, fig.cap='症例対照デザイン。アウトカムを持つ被験者（「症例」）は、アウトカムを持たない被験者（「対照」）との曝露ステータスの面で比較されます。通常、症例と対照は年齢や性別などの様々な特性で一致させられます。',echo=FALSE, out.width='90%', fig.align='center', fig.pos='h'}
knitr::include_graphics("images/PopulationLevelEstimation/caseControl.png")
```

症例対照研究 [@vandenbroucke_2012] は、「特定の疾患のアウトカムを持つ人が、その疾患を持たない人よりも特定のエージェントにより頻繁に曝露されているかどうか」を問います。このため、中心的なアイディアは、興味のあるアウトカムを経験する被験者（「症例」）を、興味のあるアウトカムを経験しない被験者（「対照」）と比較することです。表 \@ref(tab:ccChoices) の選択肢が、症例対照の質問を定義します。\index{outcome cohort!case-control design} \index{target cohort!case-control design} \index{nesting cohort!case-control design}

```{r ccChoices, echo=FALSE}
table <- read.table(header = TRUE, sep = "|", stringsAsFactors = FALSE, strip.white = TRUE, text = "
| 選択              | 説明                                               |
|:----------------- |:--------------------------------------------------------- |
| アウトカムコホート| 症例（興味のあるアウトカム）を表すコホート                        |
| 対照コホート      | 対照を表すコホート。通常、選択ロジックを使用してアウトカムコホートから自動的に導出される   |
| ターゲットコホート| 治療を表すコホート                                         |
| ネスティングコホート| 任意で症例および対照が抽出されるサブポピュレーションを定義するコホートを指定           |
| リスク時間        | 曝露ステータスをどのタイミング（通常インデックス日が基準）で考慮するか？                   |
")
table <- table[-1, 2:(ncol(table) - 1), -1]
table <- knitr::kable(table, caption = "症例対照デザインの主要な設計選択肢", booktabs = TRUE, row.names = FALSE)
if ( knitr:::is_latex_output()) {
  table <- kableExtra::kable_styling(table, full_width = FALSE)
  table <- kableExtra::column_spec(table, 2, width = "9cm")
}
table
```

通常、症例を年齢や性別などの特性で一致させて対照を選択し、症例と対照を比較しやすくします。もう1つの広く行われている方法は、興味のある曝露のいずれかの適応症と診断されたすべての人々など、特定のサブグループに分けて分析を行うことです。

## ケース・クロスオーバーデザイン

\index{case-crossover design}

```{r caseCrossover, fig.cap='ケース・クロスオーバーデザイン。アウトカムの周りの時間を、アウトカムの日付より前の事前に決められた間隔のコントロール日と比較します。',echo=FALSE, out.width='90%', fig.align='center', fig.pos='h'}
knitr::include_graphics("images/PopulationLevelEstimation/caseCrossover.png")
```

ケース・クロスオーバー [@maclure_1991] デザインは、アウトカムのタイミングでの曝露率が、アウトカムよりも前の事前に決められた日数での曝露率よりも異なるかどうかを評価します。これは、アウトカムが発生した日の特別な理由があるかどうかを判断しようとしています。表 \@ref(tab:ccrChoices) は、ケース・クロスオーバーの質問を定義する選択肢を示します。 \index{outcome cohort!case-crossover design} \index{target cohort!case-crossover design}

```{r ccrChoices, echo=FALSE}
table <- read.table(header = TRUE, sep = "|", stringsAsFactors = FALSE, strip.white = TRUE, text = "
| 選択              | 説明                                           |
|:----------------- |:------------------------------------------------------|
| アウトカムコホート| 症例（興味のあるアウトカム）を表すコホート                   |
| ターゲットコホート| 治療を表すコホート                                    |
| リスク時間        | 曝露ステータスをどのタイミング（通常インデックス日が基準）で考慮するか                   |
| 対照時間          | 対照時間として使用される期間                |
")
table <- table[-1, 2:(ncol(table) - 1), -1]
table <- knitr::kable(table, caption = "ケース・クロスオーバーデザインの主要な設計選択肢", booktabs = TRUE, row.names = FALSE)
if ( knitr:::is_latex_output()) {
  table <- kableExtra::kable_styling(table, full_width = FALSE)
  table <- kableExtra::column_spec(table, 2, width = "9cm")
}
table
```

症例は自分自身の対照として機能します。自己対照デザインとして、これらは人間間の差異による交絡に対して頑健であるべきです。ただし、アウトカムの日付が常にコントロール日付よりも後であるため、曝露の全体的な頻度が時間とともに増加する（または減少する）場合、方法は陽性バイアスを受ける可能性があります。これに対処するために、症例-時間-コントロールデザイン [@suissa_1995] が開発され、例えば年齢や性別で一致させた対照をケース・クロスオーバーデザインに追加して、曝露のトレンドを調整します。\index{case-time-control design}

## 自己対照症例シリーズデザイン

\index{self-controlled case series (SCCS) design}

```{r selfControlledCaseSeries, fig.cap='自己対照症例シリーズデザイン。曝露中のアウトカム発生率と非曝露中のアウトカム発生率を比較する。',echo=FALSE, out.width='90%', fig.align='center', fig.pos='h'}
knitr::include_graphics("images/PopulationLevelEstimation/selfControlledCaseSeries.png")
```

自己対照症例シリーズ（SCCS）デザイン [@farrington_1995; @whitaker_2006] は、曝露中のアウトカム発生率を、すべての非曝露期間中の発生率、これには曝露前、曝露間、曝露後の時間も含まれます、と比較します。これは、個人に依存したポアソン回帰であり、「患者がアウトカムを有する場合、曝露期間中の方が非曝露期間中よりもアウトカムが発生しやすいか？」という質問に答えようとします。表 \@ref(tab:sccsChoices)の選択肢が SCCS の質問を定義します。 \index{outcome cohort!SCCS design} \index{target cohort!SCCS design}

```{r sccsChoices, echo=FALSE}
table <- read.table(header = TRUE, sep = "|", stringsAsFactors = FALSE, strip.white = TRUE, text = "
| 選択              | 説明                                                  |
|:----------------- |:------------------------------------------------------ |
| ターゲットコホート | 治療を代表するコホート                                |
| アウトカムコホート | 関心のあるアウトカムを代表するコホート                |
| リスク時間         | どの時点（多くの場合、ターゲットコホートの開始日または終了日と関連のある時点）でアウトカムのリスクを考慮するか？ |
| モデル            | 時間変動する交絡因子の調整を含む効果の推定モデル        |
")
table <- table[-1,2:(ncol(table)-1), -1]
table <- knitr::kable(table, caption = "自己対照症例シリーズデザインの主な設計選択肢", booktabs = TRUE, row.names = FALSE)
if (knitr:::is_latex_output()) {
  table <- kableExtra::kable_styling(table, full_width = FALSE)
  table <- kableExtra::column_spec(table, 2, width = "9cm")
}
table
```

他の自己対照デザイン同様、SCCS は個人間の違いによる交絡に対して頑健ですが、時間変動する影響による交絡には脆弱です。これらを考慮するためのいくつかの調整が可能であり、たとえば年齢や季節を含めることができます。SCCSの特別なバリアントでは、関心のある曝露だけでなく、データベースに記録された他の薬剤すべての曝露を含めます [@simpson_2013]。これにより、モデルに数千の追加変数が追加されます。この場合、関心のある曝露以外のすべての曝露の係数に、正則化ハイパーパラメータをクロスバリデーションで選択するL1正則化が適用されます。

SCCSの重要な前提条件の一つは、観察期間の終了がアウトカムの日付と独立していることです。一部のアウトカム、特に心筋梗塞などの致命的なアウトカムにおいては、この前提が破られることがあります。SCCSの拡張版では、このような依存関係を修正するものがあります [@farrington_2011]。

## 高血圧研究のデザイン

### 問題の定義

ACE 阻害薬（ACEi）は、高血圧や虚血性心疾患を持つ患者、特にうっ血性心不全、糖尿病、慢性腎臓病などの併存疾患を持つ患者によく使用されます [@zaman_2002]。アンジオエデマは、唇、舌、口、喉頭、咽頭、または眼窩周囲の腫れとして現れる、深刻で時には命に関わる有害事象であり、これらの薬の使用と関連付けられています [@sabroe_1997]。しかし、これらの薬剤使用に関連するアンジオエデマの絶対および相対リスクについての情報は限られています。既存の証拠は、主に特定のコホート（例えば、主に男性の退役軍人やメディケイド受給者）に基づいたものであり、他の集団に一般化できない可能性があります。また、イベント数が少ない研究に基づくものであり、不安定なリスク推定を提供します [@powers_2012]。いくつかの観察研究は、ACEiをβ遮断薬と比較してアンジオエデマのリスクを評価しています [@magid_2010; @toh_2012]が、β遮断薬はもはや高血圧の一線級治療として推奨されていません [@whelton_2018]。有力な代替治療法として、チアジド類およびチアジド様利尿薬（THZ）が考えられます。これらは高血圧や急性心筋梗塞（AMI）などの関連リスクを管理する上で同様に有効であり、アンジオエデマのリスクを増加させない可能性があります。

以下では、観察医療データに我々の集団レベル推定フレームワークを適用して、次の比較推定質問に対処する方法を示します：

> ACE阻害薬の新規使用者とチアジドおよびチアジド様利尿薬の新規使用者を比較した場合のアンジオエデマのリスクはどれくらいですか？

> ACE阻害薬の新規使用者とチアジドおよびチアジド様利尿薬の新規使用者を比較した場合の急性心筋梗塞のリスクはどれくらいですか？

これらは比較効果推定の質問であるため、セクション \@ref (CohortMethod) で述べたコホート方法を適用します。

### ターゲットおよび比較対象

高血圧の治療を初めて観察された患者をACEiまたはTHZクラスのどちらかの単剤療法として利用する患者と見なします。治療開始後7日以内に他の抗高血圧薬を開始しない患者を単剤療法と定義します。患者は最初の曝露前に少なくとも1年間の継続的な観察期間および治療開始の前年または前年に記録された高血圧診断を有することを要求します。

### アウトカム

アンジオエデマは、入院または救急部（ER）訪問中の血管浮腫のコンディションコンセプトの発生として定義し、7日前には血管浮腫診断が記録されていないことを要求します。AMIは、入院またはER訪問中のAMIコンディションコンセプトの発生として定義し、180日前にはAMI診断が記録されていないことを要求します。

### リスク期間

リスク期間を治療開始の翌日から開始し、曝露が終了するまでと定義し、後続の薬剤曝露の間に30日のギャップを許容します。

### モデル

デフォルトの共変量セットを使用してPSモデルを適合させます。このセットには、人口統計、条件、薬剤、プロシージャー、メジャーメント、観察、およびいくつかの併存疾患スコアが含まれます。ACEiとTHZを共変量から除外します。可変比マッチングを行い、マッチングセットに条件付けてコックス回帰を行います。

### 研究要約

| 選択肢 | 値 |
|:---|:---|
| ターゲットコホート | 高血圧の第一選択単剤療法としてのACE阻害薬の新規使用者。 |
| 比較コホート | 高血圧の第一選択単剤療法としてのチアジドまたはチアジド様利尿薬の新規使用者。 |
| アウトカムコホート | アンジオエデマまたは急性心筋梗塞。 |
| リスク期間 | 治療開始の翌日から開始し、曝露が終了するまで。 |
| モデル | 可変比マッチングを用いたコックス比例ハザードモデル。 |

: (#tab:aceChoices) 私たちの比較コホート研究の主な設計選択肢

### コントロール質問

我々の研究デザインが真実と一致する推定を生成するかどうかを評価するために、真の効果サイズが既知の一連のコントロール質問を追加で含めます。コントロール質問は、ハザード比が1の負のコントロールと、既知のハザード比が1を超えるポジティブコントロールに分けることができます。さまざまな理由から、実際のネガティブコントロールを使用し、これらのネガティブコントロールに基づいてポジティブコントロールを合成します。コントロール質問の定義と使用方法の詳細は、第 \@ref(MethodValidity) 章で説明しています。

## ATLASを使用した研究の実施 {#PleAtlas}

ここでは、ATLASの推定機能を使用してこの研究を実施する方法を示します。ATLASの左バーで ![](images/PopulationLevelEstimation/estimation.png) をクリックし、新しい推定研究を作成します。研究に簡単に認識できる名前を付けてください。研究設計はいつでも ![](images/PopulationLevelEstimation/save.png) ボタンをクリックして保存できます。

推定設計機能には、比較、分析設定、評価設定の3つのセクションがあります。複数の比較と複数の分析設定を指定でき、それらの組み合わせを個別の分析として実行します。ここでは、それぞれのセクションについて説明します。

### 比較コホート設定 {#ComparisonSettings}

研究には1つ以上の比較を含めることができます。「比較を追加」をクリックすると、新しいダイアログが開きます。 ![](images/PopulationLevelEstimation/open.png) をクリックしてターゲットおよび比較コホートを選択します。「アウトカムを追加」をクリックして2つのアウトカムコホートを追加できます。コホートがすでにATLASで作成されていると仮定しています（第 \@ref(Cohorts) 章を参照）。ターゲット（付録 \@ref(AceInhibitorsMono)）、比較（付録 \@ref(ThiazidesMono)）、およびアウトカム（付録 \@ref(Angioedema）および付録 \@ref(Ami)）コホートの完全な定義は付録にあります。完了すると、ダイアログは図 \@ref(fig:comparisons)のようになります。

```{r comparisons, fig.cap='比較ダイアログ',echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/comparisons.png")
```

ターゲットと比較コホートのペアに対して複数のアウトカムを選択できることに注意してください。各アウトカムは独立したものとして扱われ、別々の分析アウトカムが得られます。

#### ネガティブコントロールアウトカム {.unnumbered}

ネガティブコントロールアウトカムは、ターゲットまたは比較対照によって引き起こされないと信じられているアウトカムであり、真のハザード比が1であると仮定されます。理想的には各アウトカムコホートの適切なコホート定義が必要ですが、通常は各ネガティブコントロールアウトカムごとに1つのコンセプトセットと、それらをアウトカムコホートに変換するための標準的なロジックしか持ちません。ここではコンセプトセットが第 \@ref(MethodValidity) 章で説明されているとおりすでに作成されていると仮定し、それを選択するだけです。ネガティブコントロールコンセプトセットには、ネガティブコントロールごとに1つのコンセプトが含まれ、その子孫は含まれないはずです。図 \@ref(fig:ncConceptSet) は、この研究に使用されたネガティブコントロールコンセプトセットを示しています。

```{r ncConceptSet, fig.cap='ネガティブコントロールコンセプトセット',echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/ncConceptSet.png")
```

#### 含めるコンセプト {.unnumbered}

コンセプトを選択するときに、生成したい共変量を指定できます。たとえば、傾向スコアモデルで使用するためです。ここで共変量を指定すると、それ以外の共変量（指定したもの以外）は除外されます。通常、ベースラインのすべての共変量を含め、正則化回帰モデルがすべての共変量をバランスさせるモデルを構築します。特定の共変量を指定する唯一の理由は、手動で共変量を選択した既存の研究を再現する場合です。これらの除外は、この比較セクションまたは分析セクションで指定できます。なぜなら、時には特定の比較に関連する場合（たとえば、比較における既知の交絡因子）、または特定の分析に関連する場合があります（たとえば、特定の共変量選択戦略を評価するとき）。

#### 除外するコンセプト {.unnumbered}

含めるコンセプトを指定する代わりに、*除外*するコンセプトを指定することもできます。このフィールドにコンセプトセットを送信すると、送信したコンセプトを除くすべての共変量を使用します。デフォルトの共変量セット（治療開始日のすべての薬剤およびプロシージャーを含む）を使用する場合、ターゲットおよび比較治療、およびそれらに直接関連するコンセプトを除外する必要があります。たとえば、ターゲット曝露が注射可能なものである場合、薬剤だけでなく、プロペンシティモデルからその投与手技も除外する必要があります。この例では、除外したい共変量はACEiとTHZです。図 \@ref(fig:covsToExclude) は、これらのコンセプトを含むコンセプトセットを示しています（その下位層も含まれます）。

```{r covsToExclude, fig.cap='除外するコンセプトを定義するコンセプトセット',echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/covsToExclude.png")
```

ネガティブコントロールと除外する共変量を選択した後、比較ダイアログの下半分は図 \@ref(fig:comparisons2) のようになります。

```{r comparisons2, fig.cap='ネガティブコントロールおよび除外するコンセプトセットを示す比較ウィンドウ',echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/comparisons2.png")
```

### 効果推定の分析設定

比較ダイアログを閉じた後、「分析設定を追加」をクリックできます。「分析名」とラベル付けされたボックスには、将来簡単に思い出せて見つけやすい一意の名前を付けることができます。たとえば、「傾向スコアマッチング」に設定することもできます。

#### 研究集団 {.unnumbered}

分析に入る被験者のセットである研究集団を指定するさまざまなオプションがあります。多くのオプションは、コホート定義ツールでターゲットおよび比較コホートを設計する際に利用可能なオプションと重複しています。Estimationのオプションを使用する理由の1つは再利用性です。ターゲット、比較、およびアウトカムコホートを完全に独立して定義し、後でそれらの間に依存関係を追加できます。たとえば、治療開始前にアウトカムを持っていた人を削除したい場合、ターゲットおよび比較コホートの定義でこれを行うことができますが、すべてのアウトカムごとに別のコホートを作成する必要があります。代わりに、分析設定で事前のアウトカムを持つ人々を削除することができ、これで興味のある2つのアウトカム（およびネガティブコントロールアウトカム）のターゲットおよび比較コホートを再利用できます。

**研究開始および終了日**を使用して、特定の期間に分析を制限できます。研究終了日はリスクウィンドウも切り詰め、研究終了日以降のアウトカムは考慮されません。研究開始日を選択する理由の1つは、研究している薬剤の1つが新しく、以前の期間には存在しなかったことです。自動で調整するには、「両方の曝露がデータ内に存在する期間に分析を制限しますか？」の質問に「はい」と回答します。医療行為が時間の経過とともに変わった場合（例：薬剤 警告のため）であり、特定の方法で 実践された時間にのみ興味がある場合、研究開始および終了日を調整する別の理由があります。

オプション "**Should only the first exposure per subject be included? (各対象の初回の曝露のみが含まれるべきか)**" を使用すると、患者ごとの最初の暴露に限定することができます。多くの場合、この例のようにコホート定義ですでに行われています。同様に、「**The minimum required continuous observation time prior to index date for a person to be included in the cohort (その個人をコホートに含めるための要件として、インデックス日の前の連続した観察時間の最小値)**」 というオプションは、コホート定義ですでに設定されていることが多いので、ここでは0のままにしておくことができます。インデックス日より前に観察時間がある(OBSERVATION_PERIODテーブルで定義されているように）ことは、傾向スコアを計算するのに十分な患者に関する情報があること、また患者が真の新規ユーザーであり、したがって以前に曝露されていないことを担保するためにもよく使われます。

"**Remove subjects that are in both target and comparator cohort? (ターゲットコホートと比較群コホートの両方に含まれる対象を除外しますか)**"は、"**If a subject is in multiple cohorts, should be censored time-at-risk when the new time-at-risk starts to prevent overlap? (対象が複数のコホートに含まれる場合、リスク期間の重複を避けるため、リスク期間は新しいリスク期間が開始した時点で打ち切りにしますか。)**" オプションと併せて、対象がターゲットコホートと比較コホートの両方に存在するいる場合にどのように取り扱うかを定義します。最初の設定には3つの選択肢があります：

-   "**Keep All** (すべてを保持します)" は、両方のコホートの対象を保持することを示す。このオプションでは、対象と結果がダブルカウントになる場合があります。

-   "**Keep First** (最初のコホートに保持します)" は、最初に発生したコホートに対象を残すことを示します。

-   "**Remove All** (すべてから除外します)" は、すべてのコホートから対象を除外することを示します。

もし "Keep All" または "Keep First" のオプションが選択された場合、ある対象が両方のコホートにいる時間を打ち切りたいと思うかもしれません。これを図 \@ref(fig:tar) に示します。デフォルトでは、リスク時間はコホートの開始日と終了日を基準に定義されます。この例では、リスク時間はコホート開始の1日後に始まり、コホート終了までです。2つのコホートが重なる可能性があるリスク時間を打ち切らない場合、この重複したリスク時間に発生したアウトカムは、特に、すべてを保持することを選択した場合、（ここに示されているように）重複した時間に出現したアウトカムは2回カウントされるため、問題となります。打ち切りを選択した場合、最初のコホートのリスク時間は、2番目のコホートのリスク時間の開始時に終了します。

```{r tar, fig.cap='リスク時間（Time-at-risk (TAR)）が薬剤曝露開始日から薬剤曝露終了時までと仮定した場合の2つのコホートに含まれる対象のリスク時間',echo=FALSE, out.width='90%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/tar.png")
```

アウトカムの2回目の出現は1回目の継続であることが多いため、**リスクウインドウが始まる前にアウトカムが出現した対象を除外する**ことを選択することができます。例えば、ある人に心不全が発症した場合、2回目の心不全の出現はよくあることでしょう、なぜなら1回目と2回目の心不全の間でその心不全は完全に解消することがないからです。一方、いくつかのアウトカムは間欠的なもので、上気道感染症のように、患者が複数の独立した転帰を持つことが予想されます。以前にその転帰を経験した人を除外する場合、**以前にアウトカムが出現したことを同定する際に何日前まで遡る**かを選択できます。

私たちの研究の事例での選択は、図 \@ref(fig:studyPopulation) に示されています。対象コホートと比較対象コホートの定義は、すでに初回曝露に限定しており、治療開始前の観察時間が必要なので、ここではこれらの基準は適用しません。

```{r studyPopulation, fig.cap='研究対象集団の設定',echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/studyPopulation.png")
```

#### 共変量の設定 {.unnumbered}

ここでは共変量の構成を指定します。これらの共変量は通常傾向スコアモデルで使用されますが、アウトカムモデル（この場合はCox比例ハザードモデル）にも含めることができます。**click to view details (詳細を見るにはここをクリック)**をクリックすると、どの共変量の組み合わせを使用するか、選択することが出来ます。しかし、人口統計学的要素、すべてのコンディション、薬剤、プロシージャー、メジャーメントなどを含むデフォルトのセットを使用することです。

**include (組入れ)**および/または**exclude (除外)**するコンセプトを指定することで、共変量のセットを変更できます。これらの設定は、セクション \@ref(ComparisonSettings) にある比較のための設定と同じです。これらの設定が2つの場所にある理由は、これらの設定は、比較のための薬剤を除外したい場合もある特定の比較に関連することがあるからです。特定の分析設定を使って特定の比較分析を実行するとき、OHDSIツールはこれらの集合の和を取ります。

図 \@ref(fig:covariateSettings) は、この研究で選択した内容を示しています。図 \@ref(fig:comparisons2) に定義するように、比較の設定で除外する概念に下位層を追加することを選択していることに注意して下さい。

```{r covariateSettings, fig.cap='共変量の設定',echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/covariateSettings.png")
```

#### リスク時間 {.unnumbered}

リスク時間（Time-at-risk）は、対象コホートや比較コホートにおける開始日と終了日を基準に定義されます。私たちの例では、治療開始時がコホート開始日、（少なくとも30日間）曝露中止時をコホート終了日としたので、リスク時間の開始日をコホート開始の1日後、つまり治療開始の1日後に設定しました。リスク時間の開始をコホート開始より遅く設定する理由は、治療開始当日に発生したアウトカムが薬物によるものであると生物学的に妥当でないと考えられる場合には、除外したい場合があるからです。

リスク時間の終了日は、コホートの終了日、つまり曝露が停止した時点としました。例えば、治療終了直後の事象が依然として曝露に起因すると考えられる場合は、終了日を遅く設定することもできます。極端な例では、コホート終了日の後、長い日数を経て（例えば99999日）リスク期間の終了日に設定することもできます。このようなデザインは*intent-to-treat*デザインと呼ばれることもあります。

リスク時間がゼロの患者は何の情報も提供しないので、**最小リスク日数**は通常1日に設定されます。副作用の潜伏期間がわかっている場合は、より意味のある発生割合を得るため、この日数を増やすことができます。また、比較するランダム化試験に近いコホートを作成するために使用することもできます（例えば、ランダム化試験のすべての患者が少なくともN日間観察された）。

```{block2, type='rmdimportant'}
コホート研究を計画する際の鉄則は、バイアスが含まれる可能性を除外するため、コホート開始日以降の情報を研究集団の定義に使用しないことです。例えば、全対象者に少なくとも1年間のリスク時間を要求した場合、解析対象は、治療に十分耐えられる人に限定することになります。そのため、この設定は細心の注意を払って行う必要があります。
```

```{r timeAtRisk, fig.cap='リスク時間設定',echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/timeAtRisk.png")
```

#### 傾向スコアによる調整 {.unnumbered}

傾向スコア値が極端な人を除外して、研究対象集団を**切り取って整える**ことができます。上位と下位の何パーセントを除外するか、または選好スコアが我々が指定した範囲から外れる対象を除外するかを選択できます。コホートのトリミングは、観察したことを破棄する必要があり、統計的検出力を低下させるので、一般に推奨されません。逆確率重み付け（IPTW）を使うときなど、トリミングすることが望ましい場合もあります。\index{propensity score!trimming}

トリミングに加えて、またはトリミングの代わりに、傾向スコアで**層別化**または**マッチング**を選択することができます。層別化する場合は、**層数**と、対象集団、比較対象集団、全研究対象集団のいずれに基づいて層を選択するかを指定する必要があります。マッチングの際には、**比較対象群から対象群の各人にマッチさせる最大人数**を指定する必要があります。典型的な値は、1対1のマッチングの場合は1、可変比率マッチングの場合は大きな数（例えば100）になります。また、**キャリパー**、すなわちマッチングする傾向スコア間の最大許容差を指定する必要があります。キャリパーは差の**キャリパー・スケール**で定義できます：\index{caliper!scale}

-   **傾向スコア尺度**：傾向スコアそのもの

-   **標準化尺度**：傾向スコア分布の標準偏差による

-   **標準化ロジット尺度**：傾向スコアをより正規分布にするためのロジット変換後の傾向スコア分布の標準偏差による

疑問がある場合は、デフォルト値を使用するか、 @austin_2011 によるこのトピックに関する研究を参照することをお勧めします。

大規模な傾向モデルの適合には計算コストがかかることがあるので、モデルの適合に使用するデータをデータのサンプルだけに制限したい場合があります。デフォルトでは、対象コホートと比較コホートの最大サイズは250,000に設定されています。ほとんどの研究では、この限界には達しません。また、データが多ければ多いほど、より良いモデルになるとは考えにくいです。データのサンプルはモデルのフィットに使用されるかもしれませんが、そのモデルは集団全体の傾向スコアを計算するために使用されることに注意してください。

**Test each covariate for correlation with the target assignment? (各共変量とターゲットの割付の相関を検定しますか。)** 共変量が異常に高い相関（正または負）を持つ場合、これはエラーを出力します。これにより、完全な分離を発見するためだけに傾向モデルを長時間計算することを避けることができます。非常に高い単変量相関が見つかると、なぜその共変量が高い相関を持つのか検討し、そしてその共変量を削除すべきかどうかを決定するために、その共変量を見直すことができます。

**Use regularization when fitting the model? (モデルをフィットするときに正則化をしますか。)** 標準的な手順は、傾向モデルに多くの共変量（通常10,000以上）を含めることです。このようなモデルを適合させるためには正則化が必要です。少数の厳選された共変量だけが含まれる場合は、正則化なしでモデルを適合させることも可能です。

図 \@ref(fig:psSettings) は、この研究での選択を示しています。最大マッチング人数を100人に設定することで、可変比率マッチングを選択していることに注意してください。

```{r psSettings, fig.cap='傾向スコアによる調整の設定',echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/psSettings.png")
```

#### アウトカムモデルの設定 {.unnumbered}

最初に、**対象コホートと比較コホート間のアウトカムの相対リスクを推定するために使用する統計モデルを指定する**必要があります。セクション \@ref(CohortMethod) で簡単に述べたように、Cox、Poisson、ロジスティック回帰から選択できます。この例では、打ち切りの可能性がある最初のイベントまでの時間を考慮するCox比例ハザード・モデルを選択します。次に、回帰を**層で条件付けるかどうか**を指定する必要があります。条件づけを理解する1つの方法は、各層で別々の推定が生成され、そして層で結合されること考えることです。1対1のマッチングでは、これはおそらく不要で、検出力を失うだけです。層別マッチングや可変比率マッチングでは必要です。\index{conditioned model} \index{stratified model| {conditioned model}を参照}

また、**共変量をアウトカムモデル**に追加して分析を調整することもできます。これは傾向モデルを使うことに加えて、または代わりに行うことができます。しかし、傾向モデルをフィットさせるには、両治療群に多くの人がいて十分なデータがあるのが普通ですが、アウトカムモデルをフィットさせるには、アウトカムを持つ人が少なくてデータがほとんどないのが普通です。したがって、アウトカムモデルはできるだけ単純にし、追加の共変量は含めないことをお勧めします。

傾向スコアで層別化またはマッチングする代わりに、**逆確率重み付け (IPTW)**を使うこともできます。

結果モデルにすべての共変量を含めることを選択した場合、共変量が多ければ、モデルを適合させるときに正則化を使用することが理にかなっているかもしれません。不偏推定を可能にするために、治療変数には正則化は適用されないことに注意してください。

図 \@ref(fig:outcomeModelSettings) は、この研究での私たちの選択を示しています。可変比率マッチングを用いているため、回帰モデルでは層別条件付けをしなければなりません（マッチしたセットによって）。

```{r outcomeModelSettings, fig.cap='アウトカムモデルの設定',echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/outcomeModelSettings.png")
```

### 評価の設定 {#evaluationSettings}

第 \@ref(MethodValidity) 章にあるように、ネガティブコントロールとポジティブコントロールを検討し、操作特性を評価し、経験的キャリブレーションを行う必要があります。

#### ネガティブコントロールアウトカムコホートの定義 {.unnumbered}

セクション \@ref(ComparisonSettings) では、ネガティブコントロールアウトカムを表すコンセプトセットを選択しました。しかし、分析でアウトカムとして使用するために、コンセプトをコホートに変換するロジックが必要です。ATLASは3つの選択肢を持つ標準ロジックを提供します。最初の選択肢は、**すべての出現**を使用するか、**最初の出現**だけを使用するかです。2番目の選択肢は、**下位層コンセプトの出現を考慮するかどうか**を決定します。例えば、下位層の "ingrown nail of foot (足の陥入爪)" の出現も、上位層の "ingrown nail (陥入爪)" の出現として数えることができます。3番目の選択肢は、コンセプトを探すときにどのドメインを考慮するかを指定します。

```{r ncSettings, fig.cap='ネガティブコントロールアウトカムコホートの定義の設定',echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/ncSettings.png")
```

#### ポジティブコントロールの合成 {.unnumbered}

ネガティブコントロールに加えて、因果関係があると思われる曝露-結果ペアで、効果量が既知であるポジティブコントロールも含めることができます。様々な理由から、実際のポジティブコントロールには問題があるため、その代わりに、第 \@ref(MethodValidity) 章で説明したように、ネガティブコントロールから得られる合成ポジティブコントロールを用いることがあります。**ポジティブコントロールの合成を行う**かどうかを選択できます。もし 「はい」であれば、**モデル・タイプ**を選択しなければなりませんが、現在の選択は「Poisson」と 「survival」です。私たちの集団レベルの推定の研究では生存（Cox）モデルを使用するので、「survival」を選択します。私たちは、ポジティブコントロール合成のためのリスク時間モデルを私たちの推定の設定と同じになるように定義し、同じく、**曝露前に最低限必要な連続した観察期間**、**最初の曝露のみを含めるべきか**、**最初のアウトカムのみを含めるべきか**、および**過去にアウトカムを持つ人を除外する**の選択を模倣します。図 \@ref(fig:outcomeModelSettings)にポジティブコントロール合成の設定を示します。

```{r pcSynthesis, fig.cap='ポジティブコントロールアウトカムの定義の設定',echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/pcSynthesis.png")
```

### 研究パッケージの実行

これで研究の定義が完了したので、実行可能なRパッケージとしてエクスポートできます。このパッケージは、CDMにデータを持つサイトで試験を実行するために必要なすべてを含みます。これには、ターゲット、比較群、アウトカムのコホートをインスタンス化するために使用できるコホート定義、ネガティブコントロールのコンセプト・セット、ネガティブコントロールアウトカムのコホートを作成するロジック、さらに分析を実行するRコードが含まれます。パッケージを生成する前に、必ず研究を保存し、**Utilities (ユーティリティ)** タブをクリックしてください。ここで、実行される一連の分析をレビューできます。前述したように、比較と分析設定のすべての組み合わせは、別々の分析になります。この例では、2つの解析を指定しています：AMIに対するACEi対THZ、血管性浮腫に対するACEi対THZ、両者とも傾向スコアマッチングを使用しています。

パッケージの名前を指定し、"Download (ダウンロード)" をクリックしてzipファイルをダウンロードします。zipファイルにはRパッケージが含まれており、Rパッケージに通常必要なフォルダ構造になっています [@Wickham_2015]。このパッケージを使用するには、R Studio の使用をお勧めします。R Studio をローカルで実行している場合は、ファイルを解凍し、.Rproj ファイルをダブルクリックして R Studio で開きます。RスタジオをRスタジオサーバーで実行している場合は、![](images/PopulationLevelEstimation/upload.png)をクリックしてファイルをアップロードし、解凍した後、.Rprojファイルをクリックしてプロジェクトを開きます。

R Studioでプロジェクトを開いたら、READMEファイルを開き、指示に従ってください。すべてのファイルのパスを、システム上の既存のパスに変更してください。

研究の実行時に表示される一般的なエラーメッセージは、"High correlation between covariate(s) and treatment detected."（共変量と治療の間に高い相関が検出されました。）" です。これは傾向モデルのフィッティングの際に、いくつかの共変量が曝露と高い相関があることが観察されたことを示します。エラーメッセージに記載されている共変量を確認し、適切に共変量セットから除外してください (セクション \@ref(VariableSelection) 参照). \index{high correlation}

## Rを使用した研究の実施 {#pleR}

研究を実行するためのRコードを記述するためにATLASを使用する代わりに、Rコードを自分で書くこともできます。これを行いたい理由の一つは、RがATLASで公開されているものよりもはるかに柔軟性を提供するからです。例えば、カスタム共変量や線形アウトカムモデルを使用したい場合は、カスタムRコードを作成し、OHDSI Rパッケージが提供する機能と組み合わせる必要があります。

例として、[CohortMethod](https://ohdsi.github.io/CohortMethod/)パッケージを使用して研究を実行します。CohortMethodは、CDMに含まれるデータベースから必要なデータを抽出し、プロペンシティモデルのための多数の共変量を利用できます。次の例では、最初にアウトカムとして血管浮腫のみを考慮します。セクション \@ref(MultipleAnalyses)において、これを拡張してAMIとネガティブコントロールアウトカムを含める方法について説明します。

### コホートのインスタンス化

最初にターゲットコホートおよびアウトカムコホートをインスタンス化する必要があります。コホートのインスタンス化は、セクション (\@ref(Cohorts))で説明しています。付録にはターゲット（付録 (\@ref(AceInhibitorsMono))）、比較（付録 (\@ref(ThiazidesMono))）、およびアウトカム（付録 (\@ref(Angioedema))）コホートの完全な定義が示されています。ACEi、THZ、および血管浮腫コホートが、それぞれコホート定義ID 1、2、3である `scratch.my_cohorts` という表にインスタンス化されていると仮定します。

### データ抽出

最初に、Rにサーバーへの接続方法を教える必要があります。 [CohortMethod](https://ohdsi.github.io/CohortMethod/)は[DatabaseConnector](https://ohdsi.github.io/DatabaseConnector/)パッケージを使用しており、`createConnectionDetails`という関数を提供しています。さまざまなデータベース管理システム（DBMS）に必要な特定の設定については、`?createConnectionDetails`と入力してください。たとえば、以下のコードを使用してPostgreSQLデータベースに接続できます：

```{r tidy=FALSE,eval=FALSE}
library(CohortMethod)
connDetails <- createConnectionDetails(dbms = "postgresql",
                                       server = "localhost/ohdsi",
                                       user = "joe",
                                       password = "supersecret")

cdmDbSchema <- "my_cdm_data"
cohortDbSchema <- "scratch"
cohortTable <- "my_cohorts"
cdmVersion <- "5"
```

最後の4行は`cdmDbSchema`、`cohortDbSchema`、および`cohortTable`変数と、CDMバージョンを定義しています。これらは後ほどRにCDM形式のデータがどこにあるか、関心のあるコホートがどこに作成されたか、そして使用されているCDMのバージョンを伝えるために使用します。Microsoft SQL Serverの場合、データベーススキーマはデータベースとスキーマの両方を指定する必要があるため、たとえば`cdmDbSchema <- "my_cdm_data.dbo"`のようになります。

次に、CohortMethodにコホートを抽出し、共変量を構築し、分析に必要なすべてのデータを抽出するよう指示できます：

```{r tidy=FALSE,eval=FALSE}
# ターゲットおよび比較対照薬剤の成分のコンセプト
aceI <- c(1335471,1340128,1341927,1363749,1308216,1310756,1373225,
          1331235,1334456,1342439)
thz <- c(1395058,974166,978555,907013)

# 構築すべき共変量のタイプを定義
cs <- createDefaultCovariateSettings(excludedCovariateConceptIds = c(aceI,
                                                                     thz),
                                     addDescendantsToExclude = TRUE)

# データをロード
cmData <- getDbCohortMethodData(connectionDetails = connectionDetails,
                                cdmDatabaseSchema = cdmDatabaseSchema,
                                oracleTempSchema = NULL,
                                targetId = 1,
                                comparatorId = 2,
                                outcomeIds = 3,
                                studyStartDate = "",
                                studyEndDate = "",
                                exposureDatabaseSchema = cohortDbSchema,
                                exposureTable = cohortTable,
                                outcomeDatabaseSchema = cohortDbSchema,
                                outcomeTable = cohortTable,
                                cdmVersion = cdmVersion,
                                firstExposureOnly = FALSE,
                                removeDuplicateSubjects = FALSE,
                                restrictToCommonPeriod = FALSE,
                                washoutPeriod = 0,
                                covariateSettings = cs)
cmData
```

```{r echo=FALSE,message=FALSE,eval=TRUE}
cat("CohortMethodData オブジェクト

治療コンセプトID：1
比較対照コンセプトID：2
アウトカムコンセプトID(s)：3
")
```

多くのパラメーターがありますが、すべて[CohortMethodマニュアル](https://ohdsi.github.io/CohortMethod/reference/)に文書化されています。`createDefaultCovariateSettings`関数は[FeatureExtraction](https://ohdsi.github.io/FeatureExtraction/)パッケージで説明されています。簡単に言えば、私たちのコホートを含むテーブルを指し、そのテーブル内でターゲット、比較対照、およびアウトカムを識別するコホート定義IDを指定しています。デフォルトの共変量セットが構築される指示を行い、インデックス日前日までに見つかったすべてのコンディション、薬剤曝露、およびプロシージャーに対する共変量を含むようにします。セクション (\@ref(CohortMethod))で述べたように、共変量のセットからターゲットと比較対照となる治療を除外する必要があり、ここでは、2クラスすべての成分を一覧表示し、FeatureExtractionにこれらの成分を含むすべての薬剤を除外するように指示します。

コホート、アウトカム、および共変量に関するすべてのデータはサーバーから抽出され、`cohortMethodData`オブジェクトに保存されます。このオブジェクトは`ff`パッケージを使用して情報を保存するため、データが大きくてもRがメモリ不足にならないようにします（セクション (\@ref(BigDataSupport))で述べたように）。

抽出したデータの詳細を確認するために、汎用`summary()`関数を使用できます：

```{r tidy=TRUE,eval=FALSE}
summary(cmData)
```

```{r echo=FALSE,message=FALSE}
cat("CohortMethodDataオブジェクトの要約

治療コンセプトID：1
比較対照コンセプトID：2
アウトカムコンセプトID(s)：3

治療を受けた人数：67166
比較対照の人数：35333

アウトカウント：
         イベント数         人数
3               980          891

共変量：
共変量の数：58349
ゼロでない共変量値の数：24484665
")
```

`cohortMethodData`ファイルの作成にはかなりの計算時間がかかる可能性がありますので、将来のセッションのために保存しておくのが良いでしょう。`cohortMethodData`は`ff`を使用するため、Rの通常の保存関数は使用できません。代わりに、`saveCohortMethodData()`関数を使用します：

```{r tidy=TRUE,eval=FALSE}
saveCohortMethodData(cmData, "AceiVsThzForAngioedema")
```

将来のセッションでデータをロードするには、`loadCohortMethodData()`関数を使用できます。

#### 新しいユーザーの定義 {.unnumbered}

通常、新しいユーザーは薬剤（ターゲットか比較対照のいずれか）の初回使用として定義され、初回使用として真実である確率を高めるためにウォッシュアウト期間（初回使用前の最小日数）が使用されます。CohortMethodパッケージを使用する場合、新しい使用のための必要要件を3つの方法で適用できます：

1.  コホートの定義時。
2.  コホートを`getDbCohortMethodData`関数を使用してロードする際、`firstExposureOnly`、`removeDuplicateSubjects`、`restrictToCommonPeriod`、および`washoutPeriod`引数を使用。
3.  `createStudyPopulation`関数を使用して研究集団を定義する際（下記参照）。

オプション1の利点は、入力コホートがすでにCohortMethodパッケージの外部で完全に定義されているため、外部コホート特性化ツールがこの分析で使用される同じコホートで使用できることです。オプション2および3の利点は、DRUG_ERAテーブルを直接使用できるなど、自分で初回使用に制限する手間を省くことです。オプション2は3よりも効率的であるため、最初の使用に必要なデータを取得するだけで済みますが、オプション3は効率は低いものの、元のコホートを研究集団と比較できます。

### 研究集団の定義

通常、曝露コホートとアウトカムコホートは独立して定義されます。効果サイズの推定値を算出するには、これらのコホートをさらに制限し、例えば曝露前にアウトカムが生じた被験者を除外し、定義されたリスクウィンドウ内でのみ発生したアウトカムを保持するなどの方法で、これらを一緒にする必要があります。これには`createStudyPopulation`関数を使用できます：

```{r tidy=FALSE,eval=FALSE}
studyPop <- createStudyPopulation(cohortMethodData = cmData,
                                  outcomeId = 3,
                                  firstExposureOnly = FALSE,
                                  restrictToCommonPeriod = FALSE,
                                  washoutPeriod = 0,
                                  removeDuplicateSubjects = "remove all",
                                  removeSubjectsWithPriorOutcome = TRUE,
                                  minDaysAtRisk = 1,
                                  riskWindowStart = 1,
                                  startAnchor = "cohort start",
                                  riskWindowEnd = 0,
                                  endAnchor = "cohort end")
```

`firstExposureOnly`と`removeDuplicateSubjects`をFALSEに設定し、`washoutPeriod`を0に設定しているのは、コホート定義内でこれらの基準をすでに適用しているためです。使用するアウトカムIDを指定し、リスクウィンドウの開始日より前にアウトカムがある被験者を削除するように指示します。リスクウィンドウはコホート開始日の翌日から始まり（`riskWindowStart = 1`および`startAnchor = "cohort start"`）、リスクウィンドウはコホート定義で定義された曝露終了時に終了します（`riskWindowEnd = 0`および`endAnchor = "cohort end"`）。リスクウィンドウは自動的に観察終了時または研究終了日に切り捨てられます。リスクの時間がない被験者も削除します。研究集団に残っている人数を確認するには、`getAttritionTable`関数を使用できます：

```{r tidy=TRUE,eval=FALSE}
getAttritionTable(studyPop)
```

```{r echo=FALSE,message=FALSE}
cat("                 説明   ターゲット人数 　　　比較群人数 ...
1             元のコホート         67212             35379 ...
2     両コホートの重複削除         67166             35333 ...
3     　前のアウトカムなし         67061             35238 ...
4  リスク期間が1日以上有り         66780             35086 ...")
```

### 傾向スコア

`getDbcohortMethodData()`で構築された共変量を使用してプロペンシティモデルを適合し、各個人に傾向スコア（PS）を計算できます：

```{r tidy=TRUE,eval=FALSE}
ps <- createPs(cohortMethodData = cmData, population = studyPop)
```

`createPs`関数は[Cyclops](https://ohdsi.github.io/Cyclops/)パッケージを使用して大規模な正則化ロジスティック回帰を適合します。プロペンシティモデルを適合するために、Cyclopsは事前分布の分散を指定するハイパーパラメータ値を知る必要があります。デフォルトでは、Cyclopsは交差検証を使用して最適なハイパーパラメータを推定します。ただし、これには非常に長い時間がかかる場合があります。`createPs`関数の`prior`および`control`パラメータを使用して、Cyclopsの動作を指定し、交差検証を高速化するために複数のCPUを使用するようにできます。

ここでは、変数比のマッチングを使用してPSを使用します：

```{r tidy=FALSE,eval=FALSE}
matchedPop <- matchOnPs(population = ps, caliper = 0.2,
                        caliperScale = "standardized logit", maxRatio = 100)
```

あるいは、PSを`trimByPs`、`trimByPsToEquipoise`、または`stratifyByPs`関数で使用することもできます。

### アウトカムモデル

アウトカムモデルは、どの変数がアウトカムと関連しているかを説明するモデルです。厳密な仮定の下では、治療変数の係数は因果効果として解釈できます。ここではマッチドセットに基づいたCox比例ハザードモデルを適合します：

```{r tidy=FALSE,eval=FALSE}
outcomeModel <- fitOutcomeModel(population = matchedPop,
                                modelType = "cox",
                                stratified = TRUE)
outcomeModel
```

```{r echo=FALSE,message=FALSE,eval=TRUE}
cat("モデルタイプ：cox
階層化：TRUE
共変量の使用：FALSE
治療重量の逆確率：FALSE
ステータス：OK

          推定値 下限95%  上限95%  logRr   seLogRr
治療     4.3203   2.4531   8.0771  1.4633  0.304")
```

### 複数の分析の実行 {#MultipleAnalyses}

一般的に、ネガティブコントロールを含む多くのアウトカムに対して複数の分析を実行することを希望します。[CohortMethod](https://ohdsi.github.io/CohortMethod/)は、そのような研究を効率的に実行するための関数を提供します。これは[複数の分析の実行に関するパッケージのビネット](https://ohdsi.github.io/CohortMethod/articles/MultipleAnalyses.html)で詳細に説明されています。要約すると、関心のあるアウトカムおよびネガティブコントロールコホートが既に作成されていることを前提とし、分析したいすべてのターゲット・比較対照・アウトカムの組み合わせを指定できます：

```{r tidy=FALSE,eval=FALSE}
# 関心のあるアウトカム:
ois <- c(3, 4) # Angioedema, AMI

# ネガティブコントロール：
ncs <- c(434165,436409,199192,4088290,4092879,44783954,75911,137951,77965,
         376707,4103640,73241,133655,73560,434327,4213540,140842,81378,
         432303,4201390,46269889,134438,78619,201606,76786,4115402,
         45757370,433111,433527,4170770,4092896,259995,40481632,4166231,
         433577,4231770,440329,4012570,4012934,441788,4201717,374375,
         4344500,139099,444132,196168,432593,434203,438329,195873,4083487,
         4103703,4209423,377572,40480893,136368,140648,438130,4091513,
         4202045,373478,46286594,439790,81634,380706,141932,36713918,
         443172,81151,72748,378427,437264,194083,140641,440193,4115367)

tcos <- createTargetComparatorOutcomes(targetId = 1,
                                       comparatorId = 2,
                                       outcomeIds = c(ois, ncs))

tcosList <- list(tcos)
```

次に、先ほどの例で説明した様々な関数を呼び出す際に、どのような引数を使うべきかを指定します：

```{r tidy=FALSE,eval=FALSE}
aceI <- c(1335471,1340128,1341927,1363749,1308216,1310756,1373225,
          1331235,1334456,1342439)
thz <- c(1395058,974166,978555,907013)

cs <- createDefaultCovariateSettings(excludedCovariateConceptIds = c(aceI,
                                                                     thz),
                                     addDescendantsToExclude = TRUE)

cmdArgs <- createGetDbCohortMethodDataArgs(
  studyStartDate = "",
  studyEndDate = "",
  firstExposureOnly = FALSE,
  removeDuplicateSubjects = FALSE,
  restrictToCommonPeriod = FALSE,
  washoutPeriod = 0,
  covariateSettings = cs)

spArgs <- createCreateStudyPopulationArgs(
  firstExposureOnly = FALSE,
  restrictToCommonPeriod = FALSE,
  washoutPeriod = 0,
  removeDuplicateSubjects = "remove all",
  removeSubjectsWithPriorOutcome = TRUE,
  minDaysAtRisk = 1,
  startAnchor = "cohort start",
  addExposureDaysToStart = FALSE,
  endAnchor = "cohort end",
  addExposureDaysToEnd = TRUE)

psArgs <- createCreatePsArgs()

matchArgs <- createMatchOnPsArgs(
  caliper = 0.2,
  caliperScale = "standardized logit",
  maxRatio = 100)

fomArgs <- createFitOutcomeModelArgs(
  modelType = "cox",
  stratified = TRUE)
```

次に、これらを1つの分析設定オブジェクトに結合し、一意の分析IDといくつかの説明を提供します。1つ以上の分析設定オブジェクトをリストにまとめることができます：

```{r tidy=FALSE,eval=FALSE}
cmAnalysis <- createCmAnalysis(
  analysisId = 1,
  description = "Propensity score matching",
  getDbCohortMethodDataArgs = cmdArgs,
  createStudyPopArgs = spArgs,
  createPs = TRUE,
  createPsArgs = psArgs,
  matchOnPs = TRUE,
  matchOnPsArgs = matchArgs
  fitOutcomeModel = TRUE,
  fitOutcomeModelArgs = fomArgs)

cmAnalysisList <- list(cmAnalysis)
```

これで、すべての比較と分析設定を含む研究を実行することができます：

```{r tidy=FALSE,eval=FALSE}
result <- runCmAnalyses(connectionDetails = connectionDetails,
                        cdmDatabaseSchema = cdmDatabaseSchema,
                        exposureDatabaseSchema = cohortDbSchema,
                        exposureTable = cohortTable,
                        outcomeDatabaseSchema = cohortDbSchema,
                        outcomeTable = cohortTable,
                        cdmVersion = cdmVersion,
                        outputFolder = outputFolder,
                        cmAnalysisList = cmAnalysisList,
                        targetComparatorOutcomesList = tcosList)
```

`result`オブジェクトには、作成されたすべての成果物への参照が含まれます。例えば、AMIのアウトカムモデルを取得することができます：

```{r tidy=FALSE,eval=FALSE}
omFile <- result$outcomeModelFile[result$targetId == 1 &
                                    result$comparatorId == 2 &
                                    result$outcomeId == 4 &
                                    result$analysisId == 1]
outcomeModel <- readRDS(file.path(outputFolder, omFile))
outcomeModel
```

```{r echo=FALSE,message=FALSE,eval=TRUE}
cat("Model type: cox
Stratified: TRUE
Use covariates: FALSE
Use inverse probability of treatment weighting: FALSE
Status: OK

          推定値 下限95%  上限95%  logRr   seLogRr
治療   1.1338    0.5921    2.1765 0.1256   0.332")
```

また、1つのコマンドですべてのアウトカムに対する効果量推定値を取得することもできます：

```{r tidy=FALSE,eval=FALSE}
summ <- summarizeAnalyses(result, outputFolder = outputFolder)
head(summ)
```

```{r echo=FALSE,message=FALSE,eval=TRUE}

cat("    解析ID  ターゲットID 比較群ID  アウトカムID　リスク比 ...
1            1        1            2     72748   0.9734698 ...
2            1        1            2     73241   0.7067981 ...
3            1        1            2     73560   1.0623951 ...
4            1        1            2     75911   0.9952184 ...
5            1        1            2     76786   1.0861746 ...
6            1        1            2     77965   1.1439772 ...")
```

## 研究の結果 {#studyOutputs}

私たちの推定値は、いくつかの仮定が満たされている場合にのみ有効です。これが満たされているかどうかを評価するために、広範な診断を使用します。これらはATLASによって生成されたRパッケージが生成したアウトカムで利用可能であり、または特定のR関数を使用して随時生成することもできます。

### 傾向スコアとモデル

まず、ターゲットコホートと比較対象コホートがある程度比較可能かどうかを評価する必要があります。そのためには、傾向モデルの受信者動作特性曲線(ROC)の下の面積（AUC）統計を計算できます。AUCが1である場合、治療の割り当てはベースライン共変量に基づいて完全に予測可能であり、したがって、2つのグループは比較不可能であることを示します。`computePsAuc`関数を使用してAUCを計算できます。私たちの例では0.79です。`plotPs`関数を使用して、図 \@ref(fig:ps)に示すような選好スコア分布も生成できます。この図から、多くの人々にとって受けた治療が予測可能だったことがわかりますが、大量の重複があり、調整を使用して比較可能なグループを選択できることを示しています。 \index{preference score!example}

```{r ps, fig.cap='選好スコアの分布',echo=FALSE, out.width='80%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/ps.png")
```

一般的に、特にモデルが非常に予測的である場合には、傾向モデル自体も検査することが良い考えです。その方法で、最も予測的な変数を発見できるかもしれません。表 \@ref(tab:psModel) は、私たちの傾向モデルにおける主要な予測因子を示しています。変数があまりにも予測的である場合、CohortMethodパッケージは情報的なエラーを投げますが、すでに完全に予測可能であることがわかっているモデルを適合させようとはしません。 \index{propensity model!example}

| ベータ | 共変量                                                            |
|-------:|:------------------------------------------------------------------|
|  -1.42 | 基準日から-30日から0日までの期間の疾患エラ: 浮腫                  |
|  -1.11 | 基準日から0日から0日までの期間の薬剤エラ: 塩化カリウム            |
|   0.68 | 年齢グループ: 05-09                                               |
|   0.64 | 基準日から-365日から0日までの期間のメジャーメント: レニン         |
|   0.63 | 基準日から-30日から0日までの期間の疾患エラ: 蕁麻疹                |
|   0.57 | 基準日から-30日から0日までの期間の疾患エラ: タンパク尿            |
|   0.55 | 基準日から-365日から0日までの期間の薬剤エラ: インスリン及び類似体 |
|  -0.54 | 人種: 黒人またはアフリカ系アメリカ人                              |
|   0.52 | (切片)                                                            |
|   0.50 | 性別: 男性                                                        |

: (#tab:psModel) ACEiおよびTHZの傾向モデルにおける上位10予測因子。正の値は、共変量を持つ対象が治療を受ける可能性が高いことを意味します。（切片）は、このロジスティック回帰モデルの切片を示します。

```{block2, type='rmdimportant'}
変数が非常に予測的であると判明した場合、2つの可能な結論があります。変数が明らかに曝露の一部であると判明し、モデルを適合させる前に削除する必要があるか、または2つの集団が本当に比較不可能であり、解析を中止しなければならないという結論に達します。

```

### 共変量のバランス

PSを使用する目的は、2つのグループを比較可能にすることです（少なくとも比較可能なグループを選択すること）。これが達成されたかどうかを確認する必要があります。たとえば、調整後のベースライン共変量が確かにバランスされているかどうかを確認することです。`computeCovariateBalance`および`plotCovariateBalanceScatterPlot`関数を使用して図 \@ref(fig:balance) を生成できます。指標の1つの目安は、傾向スコア調整後の絶対標準化差が0.1を超える共変量がないことです。ここでは、マッチング前には大きな不均衡がありましたが、マッチング後にはこの基準を満たしていることがわかります。 \index{covariate balance!example}

```{r balance, fig.cap='共変量バランスの図。傾向スコア マッチング前およびマッチング後の平均の絶対標準化差を示す。各ドットは共変量を表します。',echo=FALSE, out.width='70%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/balance.png")
```

### フォローアップとパワー

アウトカムモデルを適合させる前に、特定の効果サイズを検出するための十分なパワーがあるかどうかを知りたい場合があります。図 \@ref(fig:attrition) に示すように、`drawAttritionDiagram`関数を使用して私たちの研究での対象者の脱落を表示できます。 \index{attrition diagram}

```{r attrition, fig.cap='脱落図。上部に示されているカウントは目標および比較対象コホートの定義を満たしているものです。下部に示されているカウントは、アウトカムモデルに入るものです。この場合、Cox回帰です。',echo=FALSE, out.width='70%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/attrition.png")
```

レトロスペクティブ研究ではサンプルサイズは固定されており（データはすでに収集されている）、真の効果サイズは不明であるため、期待される効果サイズに基づいて電力を計算することに意味は少ないです。代わりに、CohortMethodパッケージは、最小検出可能相対リスク（MDRR）を計算するための`computeMdrr`関数を提供します。私たちの研究例におけるMDRRは1.69です。 \index{minimum detectable relative risk (MDRR)} \index{power}

追跡可能なフォローアップの量をよりよく理解するために、フォローアップ時間の分布を検査することもできます。追跡時間をリスクにさらされる時間と定義し、アウトカムが発生するまでの期間として検討できます。`getFollowUpDistribution`関数は簡単な概要を提供でき、図 \@ref(fig:followUp) に示されるように、両コホートのフォローアップ時間が比較可能であることがわかります。

```{r followUp, fig.cap='ターゲットおよび比較対象コホートのフォローアップ時間の分布',echo=FALSE, out.width='80%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/followUp.png")
```

### カプランマイヤー

最後に、カプラン−マイヤープロットをレビューし、両コホートの時間経過による生存率を示します。`plotKaplanMeier`関数を使用して \@ref(fig:kmPlot) を作成し、ハザードの比例性の仮定が保持されているかどうかなどを確認できます。カプラン−マイヤープロットはPSによる層別化や重み付けを自動的に調整します。この場合、可変比マッチングが使用されるため、比較対象グループの生存曲線は、ターゲットグループが比較対象に曝露されていた場合に曲線がどのように見えたであろうかを模倣するように調整されます。 \index{Kaplan-Meier plot} \index{survival plot|see {Kaplan-Meier plot}}

```{r kmPlot, fig.cap='カプラン−マイヤープロット',echo=FALSE, out.width='100%', fig.align='center'}
knitr::include_graphics("images/PopulationLevelEstimation/kmPlot.png")
```

### 効果サイズ推定

私たちは血管浮腫に対するハザード比は4.32（95％信頼区間：2.45 - 8.08）を観察しました。これは、ACEiがTHZと比較して血管浮腫のリスクを増加させることを示しています。同様に、AMIに対するハザード比は1.13（95％信頼区間：0.59 - 2.18）を観察し、AMIに対してはほとんどまたは全く効果がないことを示唆しています。前述の診断アウトカムは疑う理由がありません。しかし、最終的には、この証拠の質とそれを信頼するかどうかは、第 \@ref(EvidenceQuality) 章で説明されている研究診断ではカバーされていない多くの要因に依存します。

## まとめ

```{block2, type='rmdsummary'}
- 集団レベルの推定は、観察データから因果効果を推測することを目的としています。

- **反事実**とは、被験者が別の曝露または何も曝露を受けなかった場合に何が起こったかということですが、それは観察できません。

- 異なる設計は、異なる方法で反事実を構築しようとします。

- OHDSIメソッドライブラリに実装されているさまざまな設計は、適切な反事実を作成するための仮定が満たされているかどうかを評価するための診断を提供します。

```

## 演習

#### 前提条件 {.unnumbered}

これらの演習を行うためには、R、R-Studio、およびJavaがセクション \@ref(installR) で説明されているようにインストールされていることを前提とします。また、[SqlRender](https://ohdsi.github.io/SqlRender/)、[DatabaseConnector](https://ohdsi.github.io/DatabaseConnector/)、[Eunomia](https://ohdsi.github.io/Eunomia/)、および[CohortMethod](https://ohdsi.github.io/CohortMethod/)パッケージも必要です。これらは次のコマンドでインストールできます：

```{r eval=FALSE}
install.packages(c("SqlRender", "DatabaseConnector", "remotes"))
remotes::install_github("ohdsi/Eunomia", ref = "v1.0.0")
remotes::install_github("ohdsi/CohortMethod")
```

Eunomiaパッケージは、ローカルのRセッション内で実行されるCDM内のシミュレートされたデータセットを提供します。接続の詳細は次のコマンドで取得できます：

```{r eval=FALSE}
connectionDetails <- Eunomia::getEunomiaConnectionDetails()
```

CDMデータベースのスキーマは「main」です。また、これらの演習ではいくつかのコホートも使用します。Eunomiaパッケージの`createCohorts`関数を使用して、これらをCOHORTテーブル内に作成できます：

```{r eval=FALSE}
Eunomia::createCohorts(connectionDetails)
```

#### 問題定義 {.unnumbered}

> セレコキシブの新規使用者とジクロフェナクの新規使用者における消化管（GI）出血のリスクは？

セレコキシブ新規使用者コホートのCOHORT_DEFINITION_IDは1です。ジクロフェナク新規使用者コホートのCOHORT_DEFINITION_IDは2です。GI出血コホートのCOHORT_DEFINITION_IDは3です。セレコキシブとジクロフェナクの成分コンセプトIDは、それぞれ1118084と1124300です。リスク期間は治療開始の日から始まり、観察終了時に終了します（いわゆる治療意図分析）。

```{exercise, exercisePle1}
CohortMethod Rパッケージを使用して、デフォルトの共変量セットを使用し、CDMからCohortMethodDataを抽出します。CohortMethodDataのサマリーを作成します。
```

```{exercise, exercisePle2}
`createStudyPopulation`関数を使用して、180日のウォッシュアウト期間を要求し、事前にアウトカムを持つ人々を除外し、両方のコホートに出現する人々を除去して研究集団を作成します。人は失われましたか？
```

```{exercise, exercisePle3}
調整を行わずにコックス比例ハザードモデルを適合させます。これを行う際に何が問題になる可能性がありますか？
```

```{exercise, exercisePle4}
傾向スコアモデルを適合させます。2つの群は比較可能ですか？
```

```{exercise, exercisePle5}
5つの層を使用してPS階層化を行います。共変量バランスは達成されましたか？
```

```{exercise, exercisePle6}
PS階層を使用してコックス比例ハザードモデルを適合させます。そのアウトカムが無調整モデルと異なる理由は何ですか？
```

付録 \@ref(Pleanswers) に回答例があります。
